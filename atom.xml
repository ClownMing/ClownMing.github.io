<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ClownMing的私密空间</title>
  
  <subtitle>Personal blog</subtitle>
  <link href="https://clownming.github.io/atom.xml" rel="self"/>
  
  <link href="https://clownming.github.io/"/>
  <updated>2022-11-18T13:17:53.345Z</updated>
  <id>https://clownming.github.io/</id>
  
  <author>
    <name>ClownMing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>硅谷权限</title>
    <link href="https://clownming.github.io/2022/11/18/maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85(%E8%B6%85%E5%85%A8)/"/>
    <id>https://clownming.github.io/2022/11/18/maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85(%E8%B6%85%E5%85%A8)/</id>
    <published>2022-11-18T13:14:39.594Z</published>
    <updated>2022-11-18T13:17:53.345Z</updated>
    
    <content type="html"><![CDATA[<p>我们为什么要使用maven？随着我们使用越来越多的框架，我们在项目中的jar包也越来越多，几个或者十几个我们还可能方便进行管理，但是上百的jar包就有点难以管理，更别说各个jar包还具有依赖，或许我们可以花费时间整理出一套可以使用的jar包，但这并不值得我们去做。Maven作为 Java 项目提供构建和依赖管理支持的工具能够极大地方便我们的开发。</p><h1 id="第一步，maven的下载以及安装"><a href="#第一步，maven的下载以及安装" class="headerlink" title="第一步，maven的下载以及安装."></a>第一步，maven的下载以及安装.</h1><p><a href="https://maven.apache.org/download.cgi?.">点击进入maven官网</a></p><p><img src="https://img-blog.csdnimg.cn/2a11f88209ea4521ac4d98f65300e112.png"><br>找到红圈的位置下载，.gz在Linux系统常见，在这里我只演示在Windows上下载。<br>下载好后进行解压，最好路径中不要带中文，C盘或者其他盘符都行。</p><p>下载好后的目录结构<br><img src="https://img-blog.csdnimg.cn/bed10853eff64cca8f3f061e31112efd.png"><br>在解压目录中，我们需要着重关注 Maven 的核心配置文件：conf&#x2F;settings.xml</p><h1 id="指定本地仓库"><a href="#指定本地仓库" class="headerlink" title="指定本地仓库"></a>指定本地仓库</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- localRepository</span><br><span class="line"> | The path to the local repository maven will use to store artifacts.</span><br><span class="line"> |</span><br><span class="line"> | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="line">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;localRepository&gt;D:\maven3.8\workspace\mavenRepso&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p>  本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository。随着jar包越来越多，势必会拖慢C盘运行速度，影响我们的性能(C盘够大就另说)。所以建议将 Maven 的本地仓库放在其他盘符下。这里我配置在了D:\maven3.8\workspace\mavenRepso，这个路径可以不和maven包在一块，但要注意的是，中文不要出现在路径中。</p><h1 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h1>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   &lt;mirrors&gt;</span><br><span class="line">   &lt;!-- mirror</span><br><span class="line">    | Specifies a repository mirror site to use instead of a given repository. The repository that</span><br><span class="line">    | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span><br><span class="line">    | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span><br><span class="line">    |</span><br><span class="line">   &lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;mirrorId&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span><br><span class="line">   &lt;/mirror&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">&lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">&lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">&lt;url&gt;https://maven.aliyun.com/repository/public/&lt;/url&gt;</span><br><span class="line">&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"> &lt;/mirrors&gt;</span><br></pre></td></tr></table></figure><p>  首先要注意mirror标签要写在mirrors里面，原来的mirror标签内容注释掉，剩下的直接copy我的就行。</p><h1 id="配置Maven工程的JDK版本"><a href="#配置Maven工程的JDK版本" class="headerlink" title="配置Maven工程的JDK版本"></a>配置Maven工程的JDK版本</h1><p>  maven工程默认使用的jdk版本是1.5，而我们所熟知的1.8，所以需要进行修改。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;profile&gt;</span><br><span class="line">&lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line">&lt;activation&gt;</span><br><span class="line">&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">&lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">&lt;/activation&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure><br>将整个profile标签放到profiles标签中。</p><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>首先，maven是一个用java语言开发的环境，必须基于JDK来运行，我这里就默认你的电脑已经安装好了。可以在命令行使用 java -version 来查看是否安装。<br><img src="https://img-blog.csdnimg.cn/207cb866dc1d44d097b5083f69b533f8.png" alt="在这里插入图片描述"></p><h3 id="配置MAVENHOME"><a href="#配置MAVENHOME" class="headerlink" title="配置MAVENHOME"></a>配置MAVENHOME</h3><p><img src="https://img-blog.csdnimg.cn/77eb73c583d440edbb32b4e40dd8f41e.png" alt="在这里插入图片描述"></p><h3 id="配置PATH"><a href="#配置PATH" class="headerlink" title="配置PATH"></a>配置PATH</h3><p><img src="https://img-blog.csdnimg.cn/bab04479deba4a0293f9542dfdecc26f.png" alt="在这里插入图片描述"><br>除了maven安装路径不用和我一样，其他和我相同即可。</p><h1 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h1><p>命令行输入 mvn -v<br><img src="https://img-blog.csdnimg.cn/8a8fc798ab6948b08956ab712735d430.png" alt="在这里插入图片描述"><br>出现这个即配置成功!!</p>]]></content>
    
    
    <summary type="html">硅谷通用权限系统前端知识</summary>
    
    
    
    
    <category term="权限" scheme="https://clownming.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>硅谷权限</title>
    <link href="https://clownming.github.io/2022/11/18/java%EF%BC%8C%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://clownming.github.io/2022/11/18/java%EF%BC%8C%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</id>
    <published>2022-11-18T13:14:39.593Z</published>
    <updated>2022-11-18T13:17:41.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="首先先看一下什么是约瑟夫环问题"><a href="#首先先看一下什么是约瑟夫环问题" class="headerlink" title="首先先看一下什么是约瑟夫环问题"></a>首先先看一下什么是约瑟夫环问题</h1><p>据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决。Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p><p>将上面的问题具体一下：老师在幼儿园组织小朋友玩游戏，总共5个小朋友 参与，给他们一个编号：小红-小强-小兰-小明-小平，从某个学生开始数数，从1开始，数到m，数到m的人出列，再从下一个人继续从1开始数，直到剩下一个人，由此可以得到一个出列的顺序<br>。假如从小红开始，m&#x3D;2，小红、小强，小强出列，小兰、小明，小明出列，小平、小红，小红出列，小兰、小平，小平出列，最后剩下小兰。则出列顺序为：小强-小明-小红-小平-小兰。</p><p>OK，那我们用代码实现，测试我们得到的结果是否相同。</p><h3 id="首先先创建一个Boy类，这个就是我们所说的节点"><a href="#首先先创建一个Boy类，这个就是我们所说的节点" class="headerlink" title="首先先创建一个Boy类，这个就是我们所说的节点"></a>首先先创建一个Boy类，这个就是我们所说的节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Boy类，表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no; // 小孩的编号</span><br><span class="line">    private Boy next; // 指向下一个小孩节点,默认为null</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="然后创建一个类，作为环形单向链表"><a href="#然后创建一个类，作为环形单向链表" class="headerlink" title="然后创建一个类，作为环形单向链表"></a>然后创建一个类，作为环形单向链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">// 声明一个头结点，方便我们完成后面的功能</span><br><span class="line">private Boy first  = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加小孩的方法"><a href="#添加小孩的方法" class="headerlink" title="添加小孩的方法"></a>添加小孩的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   // 添加小孩节点，构建成一个环形链表</span><br><span class="line">// nums 代表需要创建几个小孩节点</span><br><span class="line">   public void addBoy(int nums) &#123; </span><br><span class="line">       // 先对num做一个数据检验</span><br><span class="line">       if (nums &lt; 1) &#123;</span><br><span class="line">           System.out.println(&quot;nums的值不正确&quot;);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       // 一定要创建辅助指针，因为我们的头结点不能够随意移动</span><br><span class="line">       Boy curBoy = null;// 辅助指针，帮助构建环形链表</span><br><span class="line">       for (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">           // 根据编号创建小孩节点</span><br><span class="line">           Boy boy = new Boy(i);</span><br><span class="line">           // 如果是第一个小孩</span><br><span class="line">           if (i == 1) &#123;</span><br><span class="line">               first = boy;</span><br><span class="line">               first.setNext(first); // 构成环装</span><br><span class="line">               curBoy = first; // 让curBoy指向第一个小孩，因为first我们不能动</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               curBoy.setNext(boy);</span><br><span class="line">               // 让最后的一个节点继续指向第一个节点，使之一直是一个环装</span><br><span class="line">               boy.setNext(first);</span><br><span class="line">               // 让curBoy指向最后一个节点，帮助我们不断构建环形链表</span><br><span class="line">               // 等遍历完，一个环形单向链表也就出现了</span><br><span class="line">               curBoy = boy;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遍历显示当前的链表"><a href="#遍历显示当前的链表" class="headerlink" title="遍历显示当前的链表"></a>遍历显示当前的链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 遍历当前的环形链表</span><br><span class="line">public void showBoy() &#123;</span><br><span class="line">// 首先先做一个非空判断，因为程序的健壮性使我们一直要考虑的因素</span><br><span class="line">// 不能因为一个欠佳考虑导致我们的程序崩溃</span><br><span class="line">    if (first == null) &#123;</span><br><span class="line">        System.out.println(&quot;链表为空!&quot;);</span><br><span class="line">        // return 表示停止一个方法的执行，这里是给刚学java小伙伴的小tip</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 因为first不能动，因此我们仍然需要使用一个指针变量</span><br><span class="line">    Boy curBoy = first;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    // java 也保留了C语言的输出函数用法</span><br><span class="line">    // 这里之所以可以用curBoy能遍历出，各个方法都在类中，现在只是单独把方法分开了</span><br><span class="line">        System.out.printf(&quot;小孩的编号为 %d \n&quot;, curBoy.getNo());</span><br><span class="line">        // 说明只剩下了一个节点</span><br><span class="line">        if (curBoy.getNext() == first) &#123; // 说明已经遍历完毕</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        curBoy = curBoy.getNext(); // curBoy后移</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好了，基本的准备工作已经完成，可以完成核心内容了</p><h3 id="根据用户的输入，计算出小孩的出圈顺序"><a href="#根据用户的输入，计算出小孩的出圈顺序" class="headerlink" title="根据用户的输入，计算出小孩的出圈顺序"></a>根据用户的输入，计算出小孩的出圈顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param startNo  表示从第几个小孩开始数数</span><br><span class="line"> * @param countNum 表示数几下</span><br><span class="line"> * @param nums     表示最初有多少小孩在圈中</span><br><span class="line"> */</span><br><span class="line">public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">    // 先对数据进行校验</span><br><span class="line">    if (first == null || startNo &lt; 0 || startNo &gt; nums) &#123;</span><br><span class="line">        System.out.println(&quot;参数输入有误，请重新输入&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建一个辅助指针，帮助小孩出圈</span><br><span class="line">    Boy helper = first;</span><br><span class="line">    // 创建的一个赋值指针helper,事先应该指向环形链表的最后一个节点</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (helper.getNext() == first) &#123;//说明helper指向最后小孩节点</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当退出循环时，辅助指针正好指向最后的一个小孩节点</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    // 小孩报数前，先让first和helper移动 startNo - 1 次</span><br><span class="line">    // 因为startNo是从第几个小孩开始，当startNo=2时，实际只移动了一个位置(因为一开始first是在第一个节点)</span><br><span class="line">    for (int j = 0; j &lt; startNo - 1; j++) &#123;</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    // 当小孩报数时，让first和helper指针同时的移动countNum - 1次，然后出圈</span><br><span class="line">    // 为什么是countNum-1?假如countNum=2时，从第一个节点开始,编号一、编号二，好，数了两次，编号二出列,实际只移动了一个节点</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    // 只有一个节点我们没必要往下进行</span><br><span class="line">        if (helper == first) &#123; // 说明圈中只有一个节点</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt;countNum - 1; j++) &#123;</span><br><span class="line">        // 这里first节点需要不断移动，因为每隔countNum-1，就要从下一个开始，相当于下一个又是一个新的第一个节点</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        // 这时first指向的节点，就是要出圈的小孩节点</span><br><span class="line">        System.out.printf(&quot;小孩 %d 出拳\n&quot;, first.getNo());</span><br><span class="line">        // 这时将first指向的小孩节点出列</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper.setNext(first);</span><br><span class="line">        // 上面两步就断开了需要出列的节点，没有引用的话，那么垃圾回收机制就会将其回收。</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(&quot;最后留在圈中的小孩编号 %d \n&quot;, first.getNo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们进行开篇的假设测试,有5个小孩，从第一个开始，每隔2个出列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">    circleSingleLinkedList.addBoy(5);</span><br><span class="line">    circleSingleLinkedList.showBoy();</span><br><span class="line">    // 测试小孩出圈</span><br><span class="line">    circleSingleLinkedList.countBoy(1, 2, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果:<br><img src="https://img-blog.csdnimg.cn/38e352dc332e4830a85bb7be618c1241.png" alt="在这里插入图片描述"></p><h1 id="最后呈现完成代码"><a href="#最后呈现完成代码" class="headerlink" title="最后呈现完成代码"></a>最后呈现完成代码</h1><p>ps:如果完整代码有不懂的可以看上面方法中的注释,那里面比较全，完整代码中好多注释我没写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">package com.dym.linkedlist;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 明312</span><br><span class="line"> * 约瑟夫环问题</span><br><span class="line"> */</span><br><span class="line">public class JosePfu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(5);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        // 测试小孩出圈</span><br><span class="line">        circleSingleLinkedList.countBoy(1, 2, 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个环形的单向链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    // 创建一个first节点，没有编号</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    // 添加小孩节点，构建成一个环形链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        // 先对num做一个数据检验</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums的值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;// 辅助指针，帮助构建环形链表</span><br><span class="line">        for (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            // 根据编号创建小孩节点</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            // 如果是第一个小孩</span><br><span class="line">            if (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first); // 构成环装</span><br><span class="line">                curBoy = first; // 让curBoy指向第一个小孩，因为first我们不能动</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 遍历当前的环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        if (first == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为first不能动，因此我们仍然需要使用一个指针变量</span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号为 %d \n&quot;, curBoy.getNo());</span><br><span class="line">            if (curBoy.getNext() == first) &#123; // 说明已经遍历完毕</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext(); // curBoy后移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据用户的输入，计算出小孩出圈的顺序</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param startNo  表示从第几个小孩开始数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有多少小孩在圈中</span><br><span class="line">     */</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        // 先对数据进行校验</span><br><span class="line">        if (first == null || startNo &lt; 0 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数输入有误，请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建一个辅助指针，帮助小孩出拳</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        // 创建的一个赋值指针helper,事先应该指向环形链表的最后一个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (helper.getNext() == first) &#123;//说明helper指向最后小孩节点</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        // 小孩报数前，先让first和helper移动 startNo - 1 次</span><br><span class="line">        for (int j = 0; j &lt; startNo - 1; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        // 当小孩报数时，让first和helper指针同时的移动countNum - 1次，然后出圈</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (helper == first) &#123; // 说明圈中只有一个节点</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 0; j &lt;countNum - 1; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            // 这时first指向的节点，就是要出圈的小孩节点</span><br><span class="line">            System.out.printf(&quot;小孩 %d 出拳\n&quot;, first.getNo());</span><br><span class="line">            // 这时将first指向的小孩节点出拳</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号 %d \n&quot;, first.getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个Boy类，表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no; // 编号</span><br><span class="line">    private Boy next; // 指向下一个节点,默认为null</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>欢迎各位指正!!</p>]]></content>
    
    
    <summary type="html">硅谷通用权限系统前端知识</summary>
    
    
    
    
    <category term="权限" scheme="https://clownming.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>硅谷权限</title>
    <link href="https://clownming.github.io/2022/11/18/idea%E6%AF%8F%E6%AC%A1%E9%85%8D%E7%BD%AEmaven%E4%BB%93%E5%BA%93%EF%BC%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%9D%A5%E4%BA%86!/"/>
    <id>https://clownming.github.io/2022/11/18/idea%E6%AF%8F%E6%AC%A1%E9%85%8D%E7%BD%AEmaven%E4%BB%93%E5%BA%93%EF%BC%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%9D%A5%E4%BA%86!/</id>
    <published>2022-11-18T13:14:39.591Z</published>
    <updated>2022-11-18T13:17:18.473Z</updated>
    
    <content type="html"><![CDATA[<p>直接上图</p><h1 id="先在idea中进行maven配置"><a href="#先在idea中进行maven配置" class="headerlink" title="先在idea中进行maven配置"></a>先在idea中进行maven配置</h1><p><img src="https://img-blog.csdnimg.cn/d92f78bded3545d4ac508429ec1dc0e4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/eb6553de4e0f4a79a5bb927a644dfe93.png" alt="在这里插入图片描述"></p><p>完成上面步骤之后，我们这个项目的maven配置就算是配置好了，但是有小伙伴发现，重新创建一个project后，maven配置又会恢复默认，这显然不是<br>我们愿意看到的。所以，接下来的操作能够让我们一劳永逸。<br><br><br>这里我使用IDEA2022.1来演示,，其他版本不会有太大变化.<br><img src="https://img-blog.csdnimg.cn/ab4a8559182e4352ac04c577a6286154.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fe2adeda99ab43e1b039d4c4103f74ac.png" alt="在这里插入图片描述"><br>至此配置完成</p>]]></content>
    
    
    <summary type="html">硅谷通用权限系统前端知识</summary>
    
    
    
    
    <category term="权限" scheme="https://clownming.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>硅谷权限</title>
    <link href="https://clownming.github.io/2022/11/18/Redis%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id/"/>
    <id>https://clownming.github.io/2022/11/18/Redis%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id/</id>
    <published>2022-11-18T13:14:39.591Z</published>
    <updated>2022-11-18T13:18:06.776Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在做秒杀活动时，每当有一个用户抢购，我们就要与之对应的生成一张订单并保存到数据库中，但是如果你使用数据库自增id时，会发现有一些问题。</p><ul><li>问题一：规律性过于明显。假如你早上买了一件商品-编号为1000，中午买了一件商品-编号为1500，晚上又买了一件商品-编号为2000，你会很容易发现这是有规律的，你甚至可以大胆推断这个商家总共卖了多少件商品，这显然不是卖家所希望看到的。<br></li><li>随着我们的规模越来越大，单表的容量有一个最佳限制，如果数据量过大，我们肯定要进行拆表，那问题来了，他们逻辑上是一张表，所以id肯定需要具有唯一性，但这种方式我们并不能保证。</li></ul><h6 id="而全局id生成器能够帮助我们解决这个问题。"><a href="#而全局id生成器能够帮助我们解决这个问题。" class="headerlink" title="而全局id生成器能够帮助我们解决这个问题。"></a>而全局id生成器能够帮助我们解决这个问题。</h6><p>全局唯一id生成器需要满足以下特性：</p><ul><li>唯一性(redis独立于数据库，只有一个，无论谁访问，自增都是唯一的，所以满足)</li><li>高可用(集群、主从、哨兵等方案可以保证，所以满足)</li><li>高性能(redis本来就以性能著称，所以满足)</li><li>递增性(redis本来就是采用递增方案,所以满足)</li><li>安全性(而安全性需要我们自己来考虑如何应对，因为单单只靠redis自带的自增方案，并不能保证安全性)<br>这里我们使用一个64位的long类型的数据作为我们的全局唯一idid组成部分：1位符号位 + 31位时间戳 + 32位序列号<br></li></ul><ol><li>首先，生成31位的时间戳<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取 2022年1月1日0时0分0秒的一个LocalDateTime实例</span><br><span class="line">LocalDateTime time = LocalDateTime.of(2022, 1, 1, 0, 0, 0);</span><br><span class="line">// 本地时间和偏移量结合</span><br><span class="line">long second = time.toEpochSecond(ZoneOffset.UTC); </span><br><span class="line">System.out.println(&quot;second = &quot; + second);</span><br></pre></td></tr></table></figure>结果为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second = 1640995200</span><br></pre></td></tr></table></figure></li></ol><p>并定义为一个静态常量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long BEGIN_TIMESTAMP = 1640995200L;</span><br></pre></td></tr></table></figure><p>生成时间戳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long timeStamp = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>生成序列号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 2.1 获取当前日期，精确到天</span><br><span class="line">// 这里yyyy:MM:dd 之所以使用冒号的更重要一个原因是可以更方便统计，因为redis可以通过冒号进行分级</span><br><span class="line">String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));</span><br><span class="line"> // 2.2 自增长</span><br><span class="line">long count = stringRedisTemplate.opsForValue().increment(&quot;custom:&quot; + keyPrefix + &quot;:&quot; + date);</span><br></pre></td></tr></table></figure></li><li><p>进行拼接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return timeStamp &lt;&lt; COUNT_BITS | count;</span><br></pre></td></tr></table></figure></li><li><p>完整代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.ZoneOffset;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author ClownMing</span><br><span class="line"> * Redis实现全局唯一id</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">public class RedisIdWorker &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开始时间戳</span><br><span class="line">     */</span><br><span class="line">    private static final long BEGIN_TIMESTAMP = 1640995200L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列号的位数</span><br><span class="line">     */</span><br><span class="line">    private static final int COUNT_BITS = 32;</span><br><span class="line"></span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long nextId(String keyPrefix)&#123; // 这个key 可以看做是业务key，不同的业务对应不同的key</span><br><span class="line">        // 1. 生成时间戳</span><br><span class="line">        long timeStamp = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;</span><br><span class="line">        // 2. 生成序列号</span><br><span class="line">        // 2.1 获取当前日期，精确到天</span><br><span class="line">        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));</span><br><span class="line">        // 2.2 自增长</span><br><span class="line">        // 这里即便没有对应的key，redis也会自动帮我们创建</span><br><span class="line">        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);</span><br><span class="line">        // 3. 拼接并返回</span><br><span class="line">        return timeStamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDateTime time = LocalDateTime.of(2022, 1, 1, 0, 0, 0);</span><br><span class="line">        long second = time.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        System.out.println(&quot;second = &quot; + second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成一定数量的id，进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   void testRedisIdWorker() throws InterruptedException &#123;</span><br><span class="line">       CountDownLatch downLatch = new CountDownLatch(200);</span><br><span class="line">       Runnable task = () -&gt; &#123;</span><br><span class="line">           for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">               long id = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">               System.out.println(&quot;id = &quot; + id);</span><br><span class="line">           &#125;</span><br><span class="line">           downLatch.countDown();</span><br><span class="line">       &#125;;</span><br><span class="line">       long begin = System.currentTimeMillis();</span><br><span class="line">       for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">           es.submit(task);</span><br><span class="line">       &#125;</span><br><span class="line">       downLatch.await();</span><br><span class="line">       long end = System.currentTimeMillis();</span><br><span class="line">       System.out.println(&quot;总耗时: &quot; + (end - begin));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/acda24391df544568f6ff59297164a5a.png" alt="在这里插入图片描述"><br>因为是异步执行，所以编号并不总是有顺序的。</p></li></ol><h3 id="测试结果正确"><a href="#测试结果正确" class="headerlink" title="测试结果正确!"></a>测试结果正确!</h3>]]></content>
    
    
    <summary type="html">硅谷通用权限系统前端知识</summary>
    
    
    
    
    <category term="权限" scheme="https://clownming.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>硅谷权限</title>
    <link href="https://clownming.github.io/2022/11/18/Redis%E4%BD%BF%E7%94%A8BitMap%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0/"/>
    <id>https://clownming.github.io/2022/11/18/Redis%E4%BD%BF%E7%94%A8BitMap%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0/</id>
    <published>2022-11-18T13:14:39.590Z</published>
    <updated>2022-11-18T13:18:35.066Z</updated>
    
    <content type="html"><![CDATA[<p>redis引入场景:</p><html>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp</html>或许有人会说，我只需要使用mysql数据库就能完成用户签到记录的功能了呀，为什么还要使用redis呢？<br><html>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp</html>用户签到一次，对应到mysql数据库中就是一条记录。![在这里插入图片描述](https://img-blog.csdnimg.cn/821073e32b7840b2b3f73766f7c01952.png)<html>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp</html>这里我们有6个字段，bigint的id、bigint的user_id、year类型的year、tiny类型的month、date类型的date、tinyint类型的is_backup。对应的字节数(8 + 8 + 1 + 1 + 3 + 1)=22字节，也就是用户签到一次就需要22字节来进行存储。我们假设一天只签到一次，按照30天来进行计算，22*30=660。也就是一个人每天签到一次，一个月需要660字节来进行存储，那当我们的用户量达到百万甚至千万，一年下来，需要的空间并不是我们可以接收的。<h3 id="redis中的BitMap结构"><a href="#redis中的BitMap结构" class="headerlink" title="redis中的BitMap结构"></a>redis中的BitMap结构</h3><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0。把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示。即便每天签到，一个月最多31位，也就是最多4个字节，与660字节相比，有百倍的容量差距。<br><br></p><h3 id="BitMap的知识大致了解"><a href="#BitMap的知识大致了解" class="headerlink" title="BitMap的知识大致了解"></a>BitMap的知识大致了解</h3><ol><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li></ol><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。<br>注意：因为BitMap底层是基于String数据结构(这里的String是redis中的String)，因此其操作也都封装在字符串相关的操作中了。</p><h3 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我们在这里使用测试工具(例如postman)进行测试</span><br><span class="line"> * 实现签到功能</span><br><span class="line"> * @return 返回值</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/api/user/sign&quot;)</span><br><span class="line">public Result sign() &#123;</span><br><span class="line">// 具体实现方法我们放到Impl中进行实现，不在controller中进行过多的代码编写</span><br><span class="line">    return userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-具体实现代码"><a href="#2-具体实现代码" class="headerlink" title="2. 具体实现代码"></a>2. 具体实现代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户签到功能</span><br><span class="line"> * @return 返回值</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Result sign() &#123;</span><br><span class="line">    // 1. 获取当前登录用户id</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    // 2. 获取日期</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    // 3. 拼接key</span><br><span class="line">    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = &quot;sign:&quot; + userId + keySuffix;</span><br><span class="line">    // 4. 获取今天是本月的第几天</span><br><span class="line">    int dayOfMonth = now.getDayOfMonth();</span><br><span class="line">    // 5. 写入redis  </span><br><span class="line">    /**</span><br><span class="line">     * 第一个参数：key，这没什么好说的，因为redis就是 key - value进行存储的(但是这个key是与现实中的月相关联的，也就是不同的月份key是不同的)</span><br><span class="line">     * 第二个参数: 这个位置是向哪个位置插入数据 这里减 1 的原因是因为redis是从0开始进行存储的，加入我们是第一天，对应到redis为下标为0</span><br><span class="line">     * 第三个参数: 填写 true或者false，代表 1或者0</span><br><span class="line">     */</span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h3><ol><li>发送请求(这里我进行了token验证，根据自己情况来)<br><img src="https://img-blog.csdnimg.cn/4e0434c1ec1442a9abcf631054e7aa6e.png" alt="image"></li><li>查看redis结果<br><img src="https://img-blog.csdnimg.cn/0cd7321eade44d84a403d394f4189c00.png" alt="image"><br>因为我是在2022年11月15日进行测试，所以key是正确的，前面的1011是用户id，202211正确。下面为什么这么多0？因为redis不是根据位来进行存储的，而是字节存储形式， 一个字节8位，所以不满8的倍数的，自动补齐0。而1是第十五个位置，测试正确!!!</li></ol><h2 id="关于上面的一些用法说明"><a href="#关于上面的一些用法说明" class="headerlink" title="关于上面的一些用法说明"></a>关于上面的一些用法说明</h2><ul><li>为什么使用StringRedisTemplate而不是使用RedisTemplate。因为如果使用RedisTemplate的话，它会在我们存储对象信息的时候，会自动添加一行关于类的来源信息，因为RedisTemplate在对象与Json转换的时候不需要我们进行手动配置，但是它需要消耗我们的内存。</li></ul>]]></content>
    
    
    <summary type="html">硅谷通用权限系统前端知识</summary>
    
    
    
    
    <category term="权限" scheme="https://clownming.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
</feed>
